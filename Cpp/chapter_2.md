
# 变量和基本类型

C++定义了一套包括`算术类型(arithmetic type)`和`空类型(void)`在内的基本数据类型

## 算术类型

算术类型分为两类: `整形(integral type, 包括字符和布尔类型在内)`和`浮点型`

类型 | 含义 | 最小尺寸
--- | --- | ---
bool | 布尔类型 | 未定义
char | 字符 | 8位
wchar_t | 宽字符 | 16位
char16_t | Unicode字符 | 16位
char32_t | Unicode字符 | 32位
short | 短整型 | 16位
int | 整形 | 16位
long | 长整型 | 32位
long long | 长整型 | 64位
float | 单精度浮点数 | 6位有效数字
double | 双精度浮点数 | 10位有效数字
long double | 扩展精度浮点数 | 10位有效数字

布尔类型(bool)的取值是真(true)或者假(false)

除去布尔型和扩展的字符型之外, 其他整形可以划分为`带符号的(signed)`和`无符号的(unsingend)`两种

带符号类型可以表示正数, 负数, 0, 无符号类型只能表示大于等于0的数

类型int, short, long 和long long 都是带符号的, 在类型名前加`unsigned`就是无符号类型, 例如 `unsigned long`. 类型`unsigned int`可以缩写为`unsigned`

字符型分为`char`, `unsigned char`, 'signed char` 特别注意类型`char`与`signed char`不一样. 类型`char`会表现成上述三种之一, 具体与编译器有关

> 如何选择类型
> - 明确知道数值不可能为负的时候, 选用无符号类型
> - 由于`short`一般与`long`一样和`int`相同, 所以普通整形选用`int`, 超过`int`表示范围的使用`long long`
> - 在算术表达式中最好不要用`char`或者`bool`, 因为在不同机器上具体值是不一样的, 如果要使用一个不大的整数, 请用`unsingned char`或者`signed char`
> - 执行浮点数运算, 选用`double`. 虽然`float`小, 但是计算速度往往与`double`相差无几, 甚至有些机器`double`比`float`快

## 类型转换

类型所能表示的值的范围决定了转换的过程

- 非布尔值 -> 布尔值 : 初始值为0则为false, 非0则为true
- 布尔值 -> 非布尔值 : 初始值为true则为1, false则为0
- 浮点数 -> 整数 : 近似值处理, 结果保留浮点数小数点前的整形部分
- 整数 -> 浮点数小数部分记为0, 如果整数超过浮点类型容量, 精度可能损失
- 赋给无符号类型超过其表示范围的值 : 结果是初始值对无符号类型表示数值总数取模后的余数. -1 赋给`unsigned char (0, 255)` 结果是该值对256取模后的余数, 为255
- 赋给带符号类型超过其表示范围的值 : 结果是`未定义(undefined)`的, 程序可能继续运行, 可能崩溃, 可能产生垃圾数据

> 避免无法预知和依赖于实现环境的行为

当无符号数中减去一个值时, 不管这个数是不是无符号数, 我们都需要确保结果不能是负值, 否则会溢出

> 切勿混用带符号类型和无符号类型

## 字面值常量

以0开头的整数表示八进制, 0x或者0X开头表示十六进制, 默认情况下, `十进制`字面值是带符号的

当两个字符串字面值位置之间仅由空格, 缩进或者换行符分隔, 则它们实际上是一个整体

转义序列

|||||||
--- | --- | --- | --- | --- | --- 
换行符 | \\n | 横向制表符 | \\t | 报警(响铃)符 | \\a
纵向制表符 | \\v | 退格符 | \\b | 双引号 | \\"
反斜线 | \\\ | 问号 | \\? | 单引号 | \\'
回车符 | \\r | 进纸符 | \\f

我们也可以使用泛化的转义序列, 其形式是\\x后紧跟一个或多个十六进制数字, 或者\\后紧跟八进制数字

我们可以通过加前缀或者后缀改变字面值的类型

字符和字符串字面值

前缀 | 含义 | 类型
--- | --- | ---
u | unicode16字符 | char16_t
U | unicode32字符 | char32_t
L | 宽字符 | wchar_t
u8 | UTF-8(仅用于字符串字面常量) | char

整型字面值

后缀 | 最小匹配类型
--- | ---
u or U | unsigned
l or L | long
ll or LL | long long

浮点型字面值

后缀 | 类型
--- | ---
f or F | float
l or L | long double

## 变量定义

```cpp
int sum = 0, value, units_sold = 0;
```
> 初始化不是赋值, 初始化是创建变量时赋予一个初始值, 赋值是将对象的当前值擦除, 用一个新值代替

### 列表初始化

```cpp
// 一下四条语句相同
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

使用花括号的初始化称为`列表初始化`, 这种初始化有一个重要特点, 当初始值存在丢失信息的风险时, 编译器会报错

```cpp
long double ld = 3.1415926536;
int a{ld}, b = {ld}; // 错误, 浮点型赋给整型会导致信息丢失, 而列表初始化会报错
int a(ld), b = ld; //正确, 非列表初始化不会报错
```

### 默认初始化

定义变量时, 没有显式初始化, 那么就会被赋予默认值, 默认是该类型的零值

有些类型必须显式初始化, 如果没有赋予初值, 会报错

> 未初始化变量引发运行时故障  
> 未初始化变量的值是不确定的, 使用未初始化变量是一种错误的编译行为, 且很难找到错误. 所以建议定义变量时同时初始化

### 变量声明和定义的关系

C++支持`分离式编译(separate compilation)`机制, 该机制允许将程序分为若干个文件, 每个文件可被独立编译

`声明(declaration)`使得名字为程序所知, 一个文件如果想要使用别的文件的变量, 必须包含那个名字的声明, 而`定义(definition)`负责创建与该名字关联的实体

如果要声明变量而非定义它, 使用`extern`关键字

```cpp
extern int i; // 声明i而非定义, 只是告诉编译器, 是有这个变量的, 具体在哪不用管
int j; // 声明j同时定义了j
```

如果给`extern`标识的变量赋予初值, 那么就成了定义

```cpp
extern double pi = 3.1415926;  // 定义
```

> 在函数体内部. 如果试图初始化一个由`extern`关键字编辑的变量, 将引发错误

> 变量能且只能被定义一次, 但是可以多次声明

### 标识符

变量命名规范等等

### 名字的作用域

`全局作用域 (global scope)`, `块作用域 (block scope)`

> 建议第一次使用变量的时候再定义它

> 函数内部不宜定义与全局变量同名的变量

## 复合类型

### 引用

`引用(refrence)`是给对象起另外的一个名字. 通过将声明符写出`&d`形式来定义引用, `d`是声明的变量名

```cpp
int ival = 1024;
int &refVal = ival; // refVal是ival的另外一个名字
int &refVal2; //错误, 引用必须被初始化
```

> **引用并非对象, 相反, 它只是一个已存在对象的另外一个名字**

修改引用就是修改对象本身

> 因为引用不是一个对象, 所以不能定义引用的引用, 引用类型初始化必须是一个对象

### 指针

`指针(pointer)`是指向另外一种类型的复合型类型, 指针写出`*d`的格式

指针存放某个对象的地址, 想要获取地址, 使用取地址符`&`

指针类型要与它指向的对象的类型严格匹配

指针的值属于一下4种状态

1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针, 以为指针没有指向任何对象
4. 无效指针, 也是上述情况外的其他值

如果指针指向了对象, 那么可以使用`解引用符(*)`来访问该对象

```cpp
int ival = 42;
int *p = &ival;  //取地址赋给指针变量p
cout << *p << endl; // 由*符号得到指针p指向的对象
```

> 解引用操作符仅适用于那些确实指向了一个明确的对象的有效指针

空指针是不指向任何对象的指针


以下是生成空指针的办法
```cpp
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL;
```

字面值`nullptr`是一种特殊类型, 表示空指针, 是c++11引入的新方法

NULL是一种预处理变量, 这个变量在`cstdlib`中定义, 它的值就是0 

预处理变量不属于空间std, 它归预处理程序管理, 所以前面不用加`std::`

> 现在的C++程序最好使用nullptr, 同时避免使用NULL

> 初始化所有指针  
> 访问未经初始化的指针所引发的后果是无法估计的, 通常会造成程序崩溃, 而且很难找到错误位置. 如果不知道指针指向何处, 就初始化成nullptr

有时候要想搞清楚一条赋值语句是修改了指针的值还是指针指向的对象的值, **最好的办法就是记住赋值永远改变的是等号左侧的`对象`**

```cpp
int ival = 42;
int *p = &ival;
*p = 0; // 等号左侧的对象是指针p指向的对象, 就是ival对象, 所以改变的是ival的值, 而指针p本身没有改变, 还是ival的地址
```

只要指针拥有合法值, 那么在条件语句中就是true, 0或者空指针就是false

```cpp
int ival = 1024;
int *p1 = 0;        // 合法, 是一个空指针
int *p2 = &ival;    // 合法, 保存ival的地址

if (p1) {}          // false
if (p2) {}          // true
```

**`类型相同的指针`**可以用 == != 比较, 返回布尔值

void* 指针是一种特殊的指针类型, 可以存放任何对象的地址, 而不管类型, 它的值任然是一个地址, 不同的是我们并不知道, 它指向的对象的类型

### 理解复合类型的声明

我们知道, 变量的定义是包括一个基本的数据类型(base type) 和一组声明符. 在同一条定义语句中, 虽然基础类型只能有一个, 但是声明符的形式却可以不同, 也就是说, 一条定义语句可以定义出不同类型的变量

```cpp
int i = 1024, *p = &i, &r = i // i: int, p: int型指针 , r: int型引用
```

**注意**

```cpp
int* p1, p2 // p1是int型指针, p2是int类型

int *p1, *p2; // p1和p2都是int型指针
```

所以有两种写法, 一种是将修饰符与基础类型放在一起, 一种是将修饰符与变量名放在一起

> 两种写法都一样, 关键是坚持一种写法而不是变来变去, 不然自己都会搞混

> 因为**引用不是对象**, 所以无法定义指向引用的指针, 但**指针是对象**, 所以可以定义指向指针的指针, 就是二重指针


## const限定符

如果我们希望一个变量的值不被改变. 可以用关键字`const`对变量的类型加以限定

```cpp
const int buffsize = 512;
buffsize = 512;   // 错误, 试图向const变量写值, 赋值是将原值擦除再赋予新值
```

> 因为const变量定义后就不能修改值了, 所以const对象必须初始化

const变量能参与大部分操作, 除了修改const对象内容的操作, 并且利用一个对象去初始化另一个对象与它们是不是const都无关紧要

默认情况下, const对象仅在文件内有效. 因为编译器在遇到const时会将其替换成对应的值, 如果在不同的文件中, 编译器就找不到对应值. 所以默认情况下const只在文件内有效

如果在多个文件中出现同名的const对象, 实际上就是两个不同的const对象, 它们之间没有关系

如果要在不同的文件中使用同一个const对象, 那么在对象的声明和定义中都要加上`extern`关键字

```cpp
// file_1.cc 定义并初始化了一个常量, 并且需要在其他文件中使用
extern const int buffsize = 512;

// file_1.h 头文件
extern const int buffsize;  // 与file_1.cc中定义的是同一个对象
```

> 如果想要在多个文件中共享同一个const对象, 那么必须在变量的定义之前添加`extern`关键字

### const的引用


### const和constexpr的区别

constexpr修饰的是编译期常量，const只是运行期常量

```cpp
const int a = 10;       // 常量，编译时确定值
const int b = a + 1;    // 常量，编译时确定值
const int c = func()    // 不是常量，具体值由func确定，但是初始化之后无法修改，
                        // 即在运行时确定
constexpr int d = func() // 常量，func返回值必须是在编译器就能确定的值
```


decltype是一个函数 返回值是类型

```cpp
int a = 10;
decltype(a); // 返回int类型
decltype(a) b = 20;  // 可以用来定义变量
```

尾后迭代器(指针)是最后一个元素后一个元素, 表示不存在此值

```cpp
 vector<int> nums = {1, 2, 3, 4, 5};
for (auto beg = nums.begin(); beg != nums.end(); ++beg)
{
    cout << *beg << endl;
}
constexpr int size = 5;
int arr[size] = {1, 2, 3, 4, 5};
for (int *i = arr; i != &arr[size]; ++i)
{
    cout << *i << endl;
}
```

c++11新标准, 可以对数组使用begin, end 函数返回数组头指针和数组尾指针

```cpp
int arr[] = {1, 2, 3, 4, 5,6};
int *beg = begin(arr);
int *ed = end(arr);         // end是函数名, 避免同名
while (beg != ed)
{
    cout << *beg++ << " ";
}
```

## 多维数组的遍历

```cpp
#include <iostream>

using namespace std;

int main()
{
    constexpr size_t rowCnt = 3, colCnt = 4;
    int ia[rowCnt][colCnt];
    for (size_t i = 0; i < rowCnt; ++i)
    {
        for (size_t j = 0; j < colCnt; ++j)
        {
            ia[i][j] = i * colCnt + j;
        }
    }

    cout << "Edition 1" << endl;

    for (int (&row)[4] : ia)
    {
        for (int n: row)
        {
            cout << n << " ";
        }
        cout << endl;
    }

    cout << endl << "Edition 2" << endl;

    for (int i = 0; i < rowCnt; ++i)
    {
        for (int j = 0; j < colCnt; ++j)
        {
            cout << ia[i][j] << " ";
        }
        cout << endl;
    }

    cout << endl << "Edition 3" << endl;

    for (int (*beg)[4] = ia; beg != ia + rowCnt; ++beg)
    {
        for (int *p = *beg; p != *beg + colCnt; ++p)
        {
            cout << *p << " ";
        }
        cout << endl;
    }

    return 0;
}
```
